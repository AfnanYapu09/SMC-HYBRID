
//@version=5
// สคริปต์แสดงจุดสูงสุดและต่ำสุด (HH & LL) พร้อมโครงสร้างตลาด
indicator('จุดสูงต่ำ HH & LL', overlay=true, max_lines_count=500)

// === การตั้งค่าพารามิเตอร์ ===
lb = input.int(5, title='จำนวนแท่งซ้าย', minval=1)
rb = input.int(5, title='จำนวนแท่งขวา', minval=1)

ph = ta.pivothigh(lb, rb)
pl = ta.pivotlow(lb, rb)
// ทิศทางแนวโน้ม: 1 = ขาขึ้น, -1 = ขาลง
iff_1 = pl ? -1 : na
hl = ph ? 1 : iff_1
// คล้าย ZigZag แต่สามารถมีหลายจุดสูง/ต่ำ
iff_2 = pl ? pl : na
zz = ph ? ph : iff_2
valuewhen_1 = ta.valuewhen(hl, hl, 1)
valuewhen_2 = ta.valuewhen(zz, zz, 1)
zz := pl and hl == -1 and valuewhen_1 == -1 and pl > valuewhen_2 ? na : zz
valuewhen_3 = ta.valuewhen(hl, hl, 1)
valuewhen_4 = ta.valuewhen(zz, zz, 1)
zz := ph and hl == 1 and valuewhen_3 == 1 and ph < valuewhen_4 ? na : zz

valuewhen_5 = ta.valuewhen(hl, hl, 1)
valuewhen_6 = ta.valuewhen(zz, zz, 1)
hl := hl == -1 and valuewhen_5 == 1 and zz > valuewhen_6 ? na : hl
valuewhen_7 = ta.valuewhen(hl, hl, 1)
valuewhen_8 = ta.valuewhen(zz, zz, 1)
hl := hl == 1 and valuewhen_7 == -1 and zz < valuewhen_8 ? na : hl
zz := na(hl) ? na : zz

// === ฟังก์ชันค้นหาค่าก่อนหน้า ===
findprevious() =>  // finds previous three points (b, c, d, e)
    ehl = hl == 1 ? -1 : 1
    loc1 = 0.0
    loc2 = 0.0
    loc3 = 0.0
    loc4 = 0.0
    xx = 0
    for x = 1 to 1000 by 1
        if hl[x] == ehl and not na(zz[x])
            loc1 := zz[x]
            xx := x + 1
            break
    ehl := hl
    for x = xx to 1000 by 1
        if hl[x] == ehl and not na(zz[x])
            loc2 := zz[x]
            xx := x + 1
            break
    ehl := hl == 1 ? -1 : 1
    for x = xx to 1000 by 1
        if hl[x] == ehl and not na(zz[x])
            loc3 := zz[x]
            xx := x + 1
            break
    ehl := hl
    for x = xx to 1000 by 1
        if hl[x] == ehl and not na(zz[x])
            loc4 := zz[x]
            break
    [loc1, loc2, loc3, loc4]

float a = na
float b = na
float c = na
float d = na
float e = na
if not na(hl)
    [loc1, loc2, loc3, loc4] = findprevious()
    a := zz
    b := loc1
    c := loc2
    d := loc3
    e := loc4
    e

_hh = zz and a > b and a > c and c > b and c > d   // จุดสูงใหม่ (HH)
_ll = zz and a < b and a < c and c < b and c < d   // จุดต่ำใหม่ (LL)
_hl = zz and (a >= c and b > c and b > d and d > c and d > e or a < b and a > c and b < d) // จุดต่ำยกสูง (HL)
_lh = zz and (a <= c and b < c and b < d and d < c and d < e or a > b and a < c and b > d) // จุดสูงย่อต่ำ (LH)

plotshape(_hl, text='HL', title='จุดต่ำยกสูง (Higher Low)', style=shape.circle, color=color.new(color.red, 0), textcolor=color.new(color.black, 0), location=location.belowbar, offset=-rb)
plotshape(_hh, text='HH', title='จุดสูงยกสูง (Higher High)', style=shape.circle, color=color.new(color.red, 0), textcolor=color.new(color.black, 0), location=location.abovebar, offset=-rb)
plotshape(_ll, text='LL', title='จุดต่ำยกต่ำ (Lower Low)', style=shape.circle, color=color.new(color.red, 0), textcolor=color.new(color.black, 0), location=location.belowbar, offset=-rb)
plotshape(_lh, text='LH', title='จุดสูงย่อต่ำ (Lower High)', style=shape.circle, color=color.new(color.red, 0), textcolor=color.new(color.black, 0), location=location.abovebar, offset=-rb)

float res = na
float sup = na
res := _lh ? zz : res[1]
sup := _hl ? zz : sup[1]

int trend = na
iff_3 = close < sup ? -1 : nz(trend[1])
trend := close > res ? 1 : iff_3




// === โครงสร้าง BOS (Break of Structure) จาก Pivot(5) ===
bosGroup         = "โครงสร้าง BOS"
showBOS          = input.bool(true, "แสดงเส้น BOS", group=bosGroup)
maxBOSLines      = input.int(50, "จำนวนเส้น BOS สูงสุด", group=bosGroup, minval=1, maxval=300)
bosBullColor     = input.color(color.new(color.lime, 0), "สีเมื่อทะลุขึ้น", group=bosGroup)
bosBearColor     = input.color(color.new(color.red, 0), "สีเมื่อทะลุลง", group=bosGroup)
bosLineWidth     = input.int(2, "ความหนาเส้น", group=bosGroup, minval=1, maxval=4)
showBOSLabel     = input.bool(true, "แสดงป้าย BOS", group=bosGroup)
bosLabelOffset   = input.int(100, "ระยะห่างป้าย (ticks)", group=bosGroup, minval=0, maxval=100)
bosLabelTextCol  = input.color(#000000, "สีตัวอักษรป้าย", group=bosGroup)
bosLabelBgBull   = input.color(color.new(color.lime, 80), "พื้นหลังป้ายขาขึ้น", group=bosGroup)
bosLabelBgBear   = input.color(color.new(color.red, 80), "พื้นหลังป้ายขาลง", group=bosGroup)

// === เส้นไส้เทียน Pivot ===
pivotWickGroup          = "เส้นไส้เทียน Pivot"
plotPivotWickHorizontal = input.bool(true, "วาดเส้นที่ไส้เทียนของ Pivot", group=pivotWickGroup)
pivotHighWickColor      = input.color(color.new(color.red, 0), "สีเส้นไส้เทียนสูงสุด", group=pivotWickGroup)
pivotLowWickColor       = input.color(color.new(color.lime, 0), "สีเส้นไส้เทียนต่ำสุด", group=pivotWickGroup)
pivotWickLineWidth      = input.int(2, "ความหนาเส้น", group=pivotWickGroup, minval=1, maxval=4)
pivotWickExtendBars     = input.int(5, "ยืดเส้นไปทางขวา", group=pivotWickGroup, minval=0, maxval=200)
maxPivotWickLines       = input.int(100, "จำนวนเส้นสูงสุด", group=pivotWickGroup, minval=1, maxval=300)

// Keep latest referenced H/L (two points) and wait for break by close
var float refHigh    = na
var int   refHighBar = na
var bool  haveRefHigh = false

var float refLow     = na
var int   refLowBar  = na
var bool  haveRefLow = false

// Store created BOS lines to cap amount
var line[] bosLines = array.new_line()
var label[] bosLabels = array.new_label()

var line  currentPivotHighWickLine = na
var float currentPivotHighWickPrice = na
var bool  pivotHighWickActive = false
var line  currentPivotLowWickLine = na
var float currentPivotLowWickPrice = na
var bool  pivotLowWickActive = false

// Storage for pivot wick lines
var line[] pivotWickLines = array.new_line()

// Capture initial/reference Pivot High/Low once, then freeze until that side is broken
// Note: ta.pivothigh/low return the pivot price confirmed rb bars ago → index is (bar_index - rb)
if not haveRefHigh and not na(ph)
    refHigh    := ph
    refHighBar := bar_index - rb
    haveRefHigh := true
    // Draw horizontal line at the pivot High candle's lowest wick
    if plotPivotWickHorizontal
        currentPivotHighWickPrice := low[rb]
        currentPivotHighWickLine  := line.new(refHighBar, currentPivotHighWickPrice, bar_index + pivotWickExtendBars, currentPivotHighWickPrice, xloc=xloc.bar_index, extend=extend.none, color=pivotHighWickColor, width=pivotWickLineWidth)
        pivotHighWickActive := true
        array.push(pivotWickLines, currentPivotHighWickLine)
        if array.size(pivotWickLines) > maxPivotWickLines
            line oldW = array.shift(pivotWickLines)
            line.delete(oldW)

if not haveRefLow and not na(pl)
    refLow    := pl
    refLowBar := bar_index - rb
    haveRefLow := true
    // Draw horizontal line at the pivot Low candle's highest wick
    if plotPivotWickHorizontal
        currentPivotLowWickPrice := high[rb]
        currentPivotLowWickLine  := line.new(refLowBar, currentPivotLowWickPrice, bar_index + pivotWickExtendBars, currentPivotLowWickPrice, xloc=xloc.bar_index, extend=extend.none, color=pivotLowWickColor, width=pivotWickLineWidth)
        pivotLowWickActive := true
        array.push(pivotWickLines, currentPivotLowWickLine)
        if array.size(pivotWickLines) > maxPivotWickLines
            line oldW2 = array.shift(pivotWickLines)
            line.delete(oldW2)

if plotPivotWickHorizontal
    if pivotHighWickActive
        if high > refHigh
            pivotHighWickActive := false
        else
            line.set_xy2(currentPivotHighWickLine, bar_index + pivotWickExtendBars, currentPivotHighWickPrice)
            if low <= currentPivotHighWickPrice
                line.set_xy1(currentPivotHighWickLine, bar_index, currentPivotHighWickPrice)
                line.set_xy2(currentPivotHighWickLine, bar_index + pivotWickExtendBars, currentPivotHighWickPrice)
    if pivotLowWickActive
        if low < refLow
            pivotLowWickActive := false
        else
            line.set_xy2(currentPivotLowWickLine, bar_index + pivotWickExtendBars, currentPivotLowWickPrice)
            if high >= currentPivotLowWickPrice
                line.set_xy1(currentPivotLowWickLine, bar_index, currentPivotLowWickPrice)
                line.set_xy2(currentPivotLowWickLine, bar_index + pivotWickExtendBars, currentPivotLowWickPrice)

// Require both reference points first, then detect breakouts by candle close (body)
if showBOS and haveRefHigh and haveRefLow
    // Up-side break: close above reference High
    if close > refHigh
        lUp = line.new(refHighBar, refHigh, bar_index, refHigh, xloc=xloc.bar_index, extend=extend.none, color=bosBullColor, width=bosLineWidth)
        array.push(bosLines, lUp)
        // Create BOS label at midpoint (above line)
        label lbUp = na
        if showBOSLabel
            midBarUp = int(math.round((refHighBar + bar_index) / 2.0))
            yUp = refHigh + bosLabelOffset * syminfo.mintick
            lbUp := label.new(midBarUp, yUp, text="BOS", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_center, textcolor=bosLabelTextCol, color=color.new(bosLabelBgBull, 100), textalign=text.align_center)
        array.push(bosLabels, lbUp)
        if array.size(bosLines) > maxBOSLines
            oldLine = array.shift(bosLines)
            line.delete(oldLine)
            oldLb = array.shift(bosLabels)
            if not na(oldLb)
                label.delete(oldLb)
        // Unlock High to wait for the next Pivot High to re-lock
        haveRefHigh := false

    // Down-side break: close below reference Low
    if close < refLow
        lDn = line.new(refLowBar, refLow, bar_index, refLow, xloc=xloc.bar_index, extend=extend.none, color=bosBearColor, width=bosLineWidth)
        array.push(bosLines, lDn)
        // Create BOS label at midpoint (below line)
        label lbDn = na
        if showBOSLabel
            midBarDn = int(math.round((refLowBar + bar_index) / 2.0))
            yDn = refLow - bosLabelOffset * syminfo.mintick
            lbDn := label.new(midBarDn, yDn, text="BOS", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_center, textcolor=bosLabelTextCol, color=color.new(bosLabelBgBear, 100), textalign=text.align_center)
        array.push(bosLabels, lbDn)
        if array.size(bosLines) > maxBOSLines
            oldLine2 = array.shift(bosLines)
            line.delete(oldLine2)
            oldLb2 = array.shift(bosLabels)
            if not na(oldLb2)
                label.delete(oldLb2)
        // Unlock Low to wait for the next Pivot Low to re-lock
        haveRefLow := false

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// === ออเดอร์บล็อก (Order Blocks) ===
obGroup      = "ออเดอร์บล็อก"
var bool showOrderblock = true
maxBoxes     = input.int(6, "จำนวนบล็อกสูงสุด", group=obGroup)
colorBull    = input.color(color.rgb(0, 64, 255, 80), "สีบล็อกขาขึ้น", group=obGroup)
colorBear    = input.color(color.rgb(255, 82, 82, 80), "สีบล็อกขาลง", group=obGroup)


// === อาร์เรย์สำหรับจัดเก็บบล็อก ===
var box[] bullBoxes = array.new_box()
var box[] bearBoxes = array.new_box()

// === ตรวจจับและวาดออเดอร์บล็อก ===
if showOrderblock
    // ── บล็อกขาขึ้น (Demand) ──
    if low > high[2]
        box ob = na
        if low[1] > high[3]
            ob := box.new(left = bar_index[2], top = high[2], right = bar_index, bottom = low[1], bgcolor = colorBull, border_color = color.new(colorBull, 100))
            box.set_text(ob, "Dz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        else if low[2] <= low[1]
            ob := box.new(left = bar_index[2], top = high[2], right = bar_index, bottom = low[2], bgcolor = colorBull, border_color = color.new(colorBull, 100))
            box.set_text(ob, "Dz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        else
            ob := box.new(left = bar_index[2], top = high[2], right = bar_index, bottom = low[1], bgcolor = colorBull, border_color = color.new(colorBull, 100))
            box.set_text(ob, "Dz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        array.push(bullBoxes, ob)
        if array.size(bullBoxes) > maxBoxes
            oldbx = array.shift(bullBoxes)
            box.delete(oldbx)

    // ── บล็อกขาลง (Supply) ──
    if high < low[2]
        box ob = na
        if high[1] < low[3]
            ob := box.new(left = bar_index[2], top = low[2], right = bar_index, bottom = high[1], bgcolor = colorBear, border_color = color.new(colorBear, 100))
            box.set_text(ob, "Sz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        else if high[2] <= high[1]
            ob := box.new(left = bar_index[2], top = low[2], right = bar_index, bottom = high[1], bgcolor = colorBear, border_color = color.new(colorBear, 100))
            box.set_text(ob, "Sz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        else
            ob := box.new(left = bar_index[2], top = low[2], right = bar_index, bottom = high[2], bgcolor = colorBear, border_color = color.new(colorBear, 100))
            box.set_text(ob, "Sz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        array.push(bearBoxes, ob)
        if array.size(bearBoxes) > maxBoxes
            oldbx = array.shift(bearBoxes)
            box.delete(oldbx)

// === ขยายบล็อกถึงแท่งปัจจุบัน ===
if array.size(bullBoxes) > 0
    for i = 0 to array.size(bullBoxes) - 1
        bx = array.get(bullBoxes, i)
        box.set_right(bx, bar_index)

if array.size(bearBoxes) > 0
    for i = 0 to array.size(bearBoxes) - 1
        bx = array.get(bearBoxes, i)
        box.set_right(bx, bar_index)

// === ลบบล็อกเมื่อราคาชนเส้น BOS ===
if array.size(bullBoxes) > 0
    for i = array.size(bullBoxes) - 1 to 0
        bx = array.get(bullBoxes, i)
        if low <= box.get_top(bx)
            box.delete(bx)
            array.remove(bullBoxes, i)

if array.size(bearBoxes) > 0
    for i = array.size(bearBoxes) - 1 to 0
        bx = array.get(bearBoxes, i)
        if high >= box.get_top(bx)  // touched top of Supply OB
            box.delete(bx)
            array.remove(bearBoxes, i)
