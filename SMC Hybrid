
//@version=5
indicator('HH & LL', overlay=true, max_lines_count=500)
lb = input.int(5, title='Left Bars', minval=1)
rb = input.int(5, title='Right Bars', minval=1)

ph = ta.pivothigh(lb, rb)
pl = ta.pivotlow(lb, rb)
iff_1 = pl ? -1 : na  // Trend direction
hl = ph ? 1 : iff_1
iff_2 = pl ? pl : na  // similar to zigzag but may have multiple highs/lows
zz = ph ? ph : iff_2
valuewhen_1 = ta.valuewhen(hl, hl, 1)
valuewhen_2 = ta.valuewhen(zz, zz, 1)
zz := pl and hl == -1 and valuewhen_1 == -1 and pl > valuewhen_2 ? na : zz
valuewhen_3 = ta.valuewhen(hl, hl, 1)
valuewhen_4 = ta.valuewhen(zz, zz, 1)
zz := ph and hl == 1 and valuewhen_3 == 1 and ph < valuewhen_4 ? na : zz

valuewhen_5 = ta.valuewhen(hl, hl, 1)
valuewhen_6 = ta.valuewhen(zz, zz, 1)
hl := hl == -1 and valuewhen_5 == 1 and zz > valuewhen_6 ? na : hl
valuewhen_7 = ta.valuewhen(hl, hl, 1)
valuewhen_8 = ta.valuewhen(zz, zz, 1)
hl := hl == 1 and valuewhen_7 == -1 and zz < valuewhen_8 ? na : hl
zz := na(hl) ? na : zz

findprevious() =>  // finds previous three points (b, c, d, e)
    ehl = hl == 1 ? -1 : 1
    loc1 = 0.0
    loc2 = 0.0
    loc3 = 0.0
    loc4 = 0.0
    xx = 0
    for x = 1 to 1000 by 1
        if hl[x] == ehl and not na(zz[x])
            loc1 := zz[x]
            xx := x + 1
            break
    ehl := hl
    for x = xx to 1000 by 1
        if hl[x] == ehl and not na(zz[x])
            loc2 := zz[x]
            xx := x + 1
            break
    ehl := hl == 1 ? -1 : 1
    for x = xx to 1000 by 1
        if hl[x] == ehl and not na(zz[x])
            loc3 := zz[x]
            xx := x + 1
            break
    ehl := hl
    for x = xx to 1000 by 1
        if hl[x] == ehl and not na(zz[x])
            loc4 := zz[x]
            break
    [loc1, loc2, loc3, loc4]

float a = na
float b = na
float c = na
float d = na
float e = na
if not na(hl)
    [loc1, loc2, loc3, loc4] = findprevious()
    a := zz
    b := loc1
    c := loc2
    d := loc3
    e := loc4
    e

_hh = zz and a > b and a > c and c > b and c > d
_ll = zz and a < b and a < c and c < b and c < d
_hl = zz and (a >= c and b > c and b > d and d > c and d > e or a < b and a > c and b < d)
_lh = zz and (a <= c and b < c and b < d and d < c and d < e or a > b and a < c and b > d)

plotshape(_hl, text='HL', title='Higher Low', style=shape.circle, color=color.new(color.red, 0), textcolor=color.new(color.black, 0), location=location.belowbar, offset=-rb)
plotshape(_hh, text='HH', title='Higher High', style=shape.circle, color=color.new(color.red, 0), textcolor=color.new(color.black, 0), location=location.abovebar, offset=-rb)
plotshape(_ll, text='LL', title='Lower Low', style=shape.circle, color=color.new(color.red, 0), textcolor=color.new(color.black, 0), location=location.belowbar, offset=-rb)
plotshape(_lh, text='LH', title='Lower High', style=shape.circle, color=color.new(color.red, 0), textcolor=color.new(color.black, 0), location=location.abovebar, offset=-rb)

float res = na
float sup = na
res := _lh ? zz : res[1]
sup := _hl ? zz : sup[1]

int trend = na
iff_3 = close < sup ? -1 : nz(trend[1])
trend := close > res ? 1 : iff_3




// === STRUCTURE BOS (Break of Structure) based on Pivot(5) ===
bosGroup         = "Structure BOS"
showBOS          = input.bool(true, "Show BOS Lines", group=bosGroup)
maxBOSLines      = input.int(50, "Max BOS Lines", group=bosGroup, minval=1, maxval=300)
bosBullColor     = input.color(color.new(color.lime, 0), "Bullish Break Color", group=bosGroup)
bosBearColor     = input.color(color.new(color.red, 0), "Bearish Break Color", group=bosGroup)
bosLineWidth     = input.int(2, "Line Width", group=bosGroup, minval=1, maxval=4)
showBOSLabel     = input.bool(true, "Show BOS Label", group=bosGroup)
bosLabelOffset   = input.int(100, "Label Offset (ticks)", group=bosGroup, minval=0, maxval=100)
bosLabelTextCol  = input.color(#000000, "Label Text Color", group=bosGroup)
bosLabelBgBull   = input.color(color.new(color.lime, 80), "Bullish Label BG", group=bosGroup)
bosLabelBgBear   = input.color(color.new(color.red, 80), "Bearish Label BG", group=bosGroup)

// Keep latest referenced H/L (two points) and wait for break by close
var float refHigh    = na
var int   refHighBar = na
var bool  haveRefHigh = false

var float refLow     = na
var int   refLowBar  = na
var bool  haveRefLow = false

// Store created BOS lines to cap amount
var line[] bosLines = array.new_line()
var label[] bosLabels = array.new_label()

// Capture initial/reference Pivot High/Low once, then freeze until that side is broken
// Note: ta.pivothigh/low return the pivot price confirmed rb bars ago → index is (bar_index - rb)
if not haveRefHigh and not na(ph)
    refHigh    := ph
    refHighBar := bar_index - rb
    haveRefHigh := true

if not haveRefLow and not na(pl)
    refLow    := pl
    refLowBar := bar_index - rb
    haveRefLow := true

// Require both reference points first, then detect breakouts by candle close (body)
if showBOS and haveRefHigh and haveRefLow
    // Up-side break: close above reference High
    if close > refHigh
        lUp = line.new(refHighBar, refHigh, bar_index, refHigh, xloc=xloc.bar_index, extend=extend.none, color=bosBullColor, width=bosLineWidth)
        array.push(bosLines, lUp)
        // Create BOS label at midpoint (above line)
        label lbUp = na
        if showBOSLabel
            midBarUp = int(math.round((refHighBar + bar_index) / 2.0))
            yUp = refHigh + bosLabelOffset * syminfo.mintick
            lbUp := label.new(midBarUp, yUp, text="BOS", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_center, textcolor=bosLabelTextCol, color=color.new(bosLabelBgBull, 100), textalign=text.align_center)
        array.push(bosLabels, lbUp)
        if array.size(bosLines) > maxBOSLines
            oldLine = array.shift(bosLines)
            line.delete(oldLine)
            oldLb = array.shift(bosLabels)
            if not na(oldLb)
                label.delete(oldLb)
        // Unlock High to wait for the next Pivot High to re-lock
        haveRefHigh := false

    // Down-side break: close below reference Low
    if close < refLow
        lDn = line.new(refLowBar, refLow, bar_index, refLow, xloc=xloc.bar_index, extend=extend.none, color=bosBearColor, width=bosLineWidth)
        array.push(bosLines, lDn)
        // Create BOS label at midpoint (below line)
        label lbDn = na
        if showBOSLabel
            midBarDn = int(math.round((refLowBar + bar_index) / 2.0))
            yDn = refLow - bosLabelOffset * syminfo.mintick
            lbDn := label.new(midBarDn, yDn, text="BOS", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_center, textcolor=bosLabelTextCol, color=color.new(bosLabelBgBear, 100), textalign=text.align_center)
        array.push(bosLabels, lbDn)
        if array.size(bosLines) > maxBOSLines
            oldLine2 = array.shift(bosLines)
            line.delete(oldLine2)
            oldLb2 = array.shift(bosLabels)
            if not na(oldLb2)
                label.delete(oldLb2)
        // Unlock Low to wait for the next Pivot Low to re-lock
        haveRefLow := false

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// === INPUTS ===
obGroup      = "Order Blocks"
var bool showOrderblock = true
maxBoxes     = input.int(6, "Max Boxes", group=obGroup)
colorBull    = input.color(color.rgb(0, 64, 255, 80), "Bullish OB Color", group=obGroup)
colorBear    = input.color(color.rgb(255, 82, 82, 80), "Bearish OB Color", group=obGroup)


// === ARRAYS ===
var box[] bullBoxes = array.new_box()
var box[] bearBoxes = array.new_box()

// === DETECT & DRAW ORDER BLOCKS ===
if showOrderblock
    // ── Bullish Order Block (Demand) ──
    if low > high[2]
        box ob = na
        if low[1] > high[3]
            ob := box.new(left = bar_index[2], top = high[2], right = bar_index, bottom = low[1], bgcolor = colorBull, border_color = color.new(colorBull, 100))
            box.set_text(ob, "Dz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        else if low[2] <= low[1]
            ob := box.new(left = bar_index[2], top = high[2], right = bar_index, bottom = low[2], bgcolor = colorBull, border_color = color.new(colorBull, 100))
            box.set_text(ob, "Dz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        else
            ob := box.new(left = bar_index[2], top = high[2], right = bar_index, bottom = low[1], bgcolor = colorBull, border_color = color.new(colorBull, 100))
            box.set_text(ob, "Dz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        array.push(bullBoxes, ob)
        if array.size(bullBoxes) > maxBoxes
            oldbx = array.shift(bullBoxes)
            box.delete(oldbx)

    // ── Bearish Order Block (Supply) ──
    if high < low[2]
        box ob = na
        if high[1] < low[3]
            ob := box.new(left = bar_index[2], top = low[2], right = bar_index, bottom = high[1], bgcolor = colorBear, border_color = color.new(colorBear, 100))
            box.set_text(ob, "Sz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        else if high[2] <= high[1]
            ob := box.new(left = bar_index[2], top = low[2], right = bar_index, bottom = high[1], bgcolor = colorBear, border_color = color.new(colorBear, 100))
            box.set_text(ob, "Sz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        else
            ob := box.new(left = bar_index[2], top = low[2], right = bar_index, bottom = high[2], bgcolor = colorBear, border_color = color.new(colorBear, 100))
            box.set_text(ob, "Sz")
            box.set_text_halign(ob, text.align_right)
            box.set_text_size(ob, size.small)
        array.push(bearBoxes, ob)
        if array.size(bearBoxes) > maxBoxes
            oldbx = array.shift(bearBoxes)
            box.delete(oldbx)

// === EXTEND BOXES TO CURRENT BAR ===
if array.size(bullBoxes) > 0
    for i = 0 to array.size(bullBoxes) - 1
        bx = array.get(bullBoxes, i)
        box.set_right(bx, bar_index)

if array.size(bearBoxes) > 0
    for i = 0 to array.size(bearBoxes) - 1
        bx = array.get(bearBoxes, i)
        box.set_right(bx, bar_index)

// === DELETE BOXES WHEN BOS (Break of Structure) TOUCH ===
if array.size(bullBoxes) > 0
    for i = array.size(bullBoxes) - 1 to 0
        bx = array.get(bullBoxes, i)
        if low <= box.get_top(bx)
            box.delete(bx)
            array.remove(bullBoxes, i)

if array.size(bearBoxes) > 0
    for i = array.size(bearBoxes) - 1 to 0
        bx = array.get(bearBoxes, i)
        if high >= box.get_top(bx)  // touched top of Supply OB
            box.delete(bx)
            array.remove(bearBoxes, i)
